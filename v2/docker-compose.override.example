# Docker Compose Override для оптимизации производительности на слабом проде
# Скопируйте в docker-compose.override.yml и настройте под ваше окружение

services:
  app:
    environment:
      # Database Connection Pool - оптимизированы для слабого сервера
      - DB_POOL_SIZE=3               # Меньше соединений для экономии ресурсов
      - DB_MAX_OVERFLOW=5            # Меньше overflow соединений
      - DB_POOL_TIMEOUT=30           # Быстрее timeout для освобождения соединений
      - DB_STATEMENT_TIMEOUT=30000   # 30s на запрос (вместо 5min)
      - DB_POOL_PRE_PING=true        # Проверка соединений
      - DB_POOL_RECYCLE=1800         # 30min вместо 1 часа

      # Application Performance
      - MAX_WORKERS=2                # Меньше воркеров для экономии памяти
      - DEVELOPMENT=false            # Продакшн режим
      - LOG_LEVEL=WARNING            # Меньше логирования

      # Feed API Optimization (новые переменные для тонкой настройки)
      - FEED_DEFAULT_LIMIT=10        # Меньше статей в ответе по умолчанию
      - FEED_MAX_LIMIT=50            # Максимум статей в feed
      - ENABLE_QUERY_OPTIMIZATION=true  # Включить оптимизированные запросы
      
  postgres:
    environment:
      # PostgreSQL оптимизация для слабого сервера
      POSTGRES_SHARED_BUFFERS: 32MB     # Еще меньше памяти
      POSTGRES_MAX_CONNECTIONS: 25      # Меньше соединений
      POSTGRES_EFFECTIVE_CACHE_SIZE: 64MB
      POSTGRES_WORK_MEM: 2MB            # Память на запрос
      POSTGRES_MAINTENANCE_WORK_MEM: 8MB
      
    # Дополнительные оптимизации PostgreSQL
    command: >
      postgres
      -c max_connections=25
      -c shared_buffers=32MB
      -c effective_cache_size=64MB
      -c work_mem=2MB
      -c maintenance_work_mem=8MB
      -c random_page_cost=1.1
      -c effective_io_concurrency=200
      -c checkpoint_completion_target=0.9
      -c wal_buffers=16MB
      -c default_statistics_target=100
      -c synchronous_commit=off
      -c wal_level=minimal
      -c max_wal_senders=0